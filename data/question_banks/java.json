{
  "exam_sets": [
    {
      "name": "Java Core Fundamentals",
      "topic_id": "java",
      "difficulty": "Medium",
      "questions": [
        {
          "id": "d5_q001_s1",
          "domain": "JVM Architecture",
          "difficulty": "Easy",
          "question_text": "Which JVM memory area stores method and class-level data, including the runtime constant pool?",
          "options": [
            "A) Heap Area",
            "B) Stack Area",
            "C) Method Area",
            "D) PC Register"
          ],
          "correct_answer_index": 2,
          "explanation": "The Method Area is a shared runtime data area in the JVM that stores per-class structures such as the runtime constant pool, field and method data, and the code for methods and constructors. The Heap is for objects, the Stack is for thread-local method execution, and PC Registers track the current instruction."
        },
        {
          "id": "d5_q002_s1",
          "domain": "Java Language Basics",
          "difficulty": "Easy",
          "question_text": "What is the result of the expression `5 + 15 / 3 * 2 - 8 % 3` in Java?",
          "options": [
            "A) 13",
            "B) 11.67",
            "C) 7",
            "D) 15"
          ],
          "correct_answer_index": 0,
          "explanation": "Due to operator precedence, multiplication, division, and modulus are evaluated first from left to right. So, `15 / 3` is 5. Then `5 * 2` is 10. Then `8 % 3` is 2. The expression becomes `5 + 10 - 2`, which evaluates to 13."
        },
        {
          "id": "d5_q003_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Medium",
          "question_text": "Which OOP principle allows a subclass to provide a specific implementation of a method that is already provided by its superclass?",
          "options": [
            "A) Encapsulation",
            "B) Inheritance",
            "C) Method Overriding (Polymorphism)",
            "D) Method Overloading"
          ],
          "correct_answer_index": 2,
          "explanation": "Method overriding is a feature of runtime polymorphism in Java where a subclass provides a specific implementation for a method that is already defined in its parent class. This allows a class to inherit from a superclass whose behavior is 'close enough' and then modify behavior as needed."
        },
        {
          "id": "d5_q004_s1",
          "domain": "Java 8 Features",
          "difficulty": "Medium",
          "question_text": "What is the primary purpose of the `Optional` class introduced in Java 8?",
          "options": [
            "A) To make methods optional to implement in an interface.",
            "B) To replace all uses of `null` in an application.",
            "C) To provide a type-safe container for a value that may be absent, helping to avoid NullPointerExceptions.",
            "D) To provide an optional, alternative implementation for a class."
          ],
          "correct_answer_index": 2,
          "explanation": "The `Optional` class is a container object which may or may not contain a non-null value. Its main purpose is to provide a better way to handle `null` values by making it explicit that a value may be absent, thus forcing developers to handle that case and reducing the risk of `NullPointerException`."
        },
        {
          "id": "d5_q005_s1",
          "domain": "Collections Framework",
          "difficulty": "Easy",
          "question_text": "Which collection class is an ordered collection that allows duplicate elements and provides fast random access?",
          "options": [
            "A) HashSet",
            "B) LinkedList",
            "C) ArrayList",
            "D) TreeMap"
          ],
          "correct_answer_index": 2,
          "explanation": "`ArrayList` is an implementation of the `List` interface that is backed by a dynamic array. This allows for fast random access (O(1) time complexity) because elements can be accessed directly via their index. It maintains insertion order and allows duplicate elements."
        },
        {
          "id": "d5_q006_s1",
          "domain": "Concurrency",
          "difficulty": "Medium",
          "question_text": "What is the main difference between `Runnable` and `Callable` interfaces in Java concurrency?",
          "options": [
            "A) `Runnable` can return a value, while `Callable` cannot.",
            "B) `Callable` can return a value and throw a checked exception, while `Runnable` cannot.",
            "C) `Callable` is an older interface replaced by `Runnable`.",
            "D) `Runnable` tasks are executed by `ExecutorService`, while `Callable` tasks are not."
          ],
          "correct_answer_index": 1,
          "explanation": "The `Callable` interface is similar to `Runnable`, in that both are designed for classes whose instances are intended to be executed by another thread. However, a `Callable` can return a result (via a `Future` object) and is able to throw a checked exception, whereas the `run()` method of a `Runnable` has a `void` return type and cannot throw checked exceptions."
        },
        {
          "id": "d5_q007_s1",
          "domain": "JVM Architecture",
          "difficulty": "Medium",
          "question_text": "In the context of JVM garbage collection, what does a 'stop-the-world' pause mean?",
          "options": [
            "A) The entire JVM process is terminated and restarted.",
            "B) All application threads are paused while the garbage collection process runs.",
            "C) Only the thread that triggered the garbage collection is paused.",
            "D) The garbage collector stops collecting garbage to allow the application to run."
          ],
          "correct_answer_index": 1,
          "explanation": "A 'stop-the-world' (STW) event is a phase during garbage collection where the JVM temporarily stops all running application threads to perform its memory cleanup tasks safely. The length of these pauses is a critical performance consideration for many applications."
        },
        {
          "id": "d5_q008_s1",
          "domain": "Java Language Basics",
          "difficulty": "Medium",
          "question_text": "Which access modifier restricts access to members of a class to the class itself, any subclasses, and other classes in the same package?",
          "options": [
            "A) public",
            "B) private",
            "C) protected",
            "D) default (package-private)"
          ],
          "correct_answer_index": 2,
          "explanation": "The `protected` access modifier makes a member accessible within its own package and also accessible to subclasses, even if they are in a different package. `private` is most restrictive, and `default` only allows access within the same package."
        },
        {
          "id": "d5_q009_s1",
          "domain": "Java 8 Features",
          "difficulty": "Medium",
          "question_text": "What is a 'functional interface' in Java 8?",
          "options": [
            "A) An interface with only functional methods.",
            "B) An interface that can have only one method.",
            "C) Any interface used in a functional programming context.",
            "D) An interface that has exactly one abstract method (SAM)."
          ],
          "correct_answer_index": 3,
          "explanation": "A functional interface is an interface that contains exactly one abstract method. They are also known as Single Abstract Method (SAM) interfaces. They can have multiple default or static methods. They are used as the target type for lambda expressions and method references."
        },
        {
          "id": "d5_q010_s1",
          "domain": "Collections Framework",
          "difficulty": "Medium",
          "question_text": "What is a key difference between `HashMap` and `TreeMap`?",
          "options": [
            "A) `HashMap` allows null values, but `TreeMap` does not.",
            "B) `HashMap` stores key-value pairs, while `TreeMap` stores only keys.",
            "C) `HashMap` does not guarantee any order, while `TreeMap` maintains its entries in sorted order based on the natural ordering of keys or a provided Comparator.",
            "D) `TreeMap` is faster for lookups than `HashMap`."
          ],
          "correct_answer_index": 2,
          "explanation": "The primary difference is ordering. `HashMap` makes no guarantees about the iteration order. `TreeMap`, on the other hand, is a `SortedMap` implementation that maintains its entries in ascending key order, which can be either the natural order of the keys or an order defined by a `Comparator`."
        },
        {
          "id": "d5_q011_s1",
          "domain": "Concurrency",
          "difficulty": "Hard",
          "question_text": "What does the `volatile` keyword in Java guarantee?",
          "options": [
            "A) It guarantees that operations on the variable are atomic.",
            "B) It guarantees that the variable is stored only in main memory, not in CPU caches.",
            "C) It guarantees visibility of changes to variables across threads.",
            "D) It guarantees both atomicity and visibility."
          ],
          "correct_answer_index": 2,
          "explanation": "`volatile` guarantees that any write to a volatile variable will be visible to any subsequent read by another thread. It ensures that reads and writes happen from/to main memory. However, it does NOT guarantee atomicity for compound operations like `i++`."
        },
        {
          "id": "d5_q012_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Medium",
          "question_text": "What is the 'diamond problem' in the context of multiple inheritance, and how does Java 8+ address it for interfaces?",
          "options": [
            "A) It refers to the ambiguity when a class inherits from two classes with the same method; Java solves it by disallowing multiple class inheritance.",
            "B) It is a performance issue with diamond-shaped inheritance trees; Java solves it with optimized virtual method tables.",
            "C) It refers to the ambiguity when a class implements two interfaces with the same default method; Java requires the implementing class to provide its own implementation.",
            "D) Both A and C are correct."
          ],
          "correct_answer_index": 3,
          "explanation": "The diamond problem arises when a class inherits from two superclasses that have a common ancestor. Java avoids this by not allowing multiple inheritance of classes. However, with default methods in interfaces (Java 8+), a similar issue can occur. If a class implements two interfaces that provide a default implementation for the same method, the compiler forces the implementing class to explicitly override the method to resolve the ambiguity."
        },
        {
          "id": "d5_q013_s1",
          "domain": "Java Language Basics",
          "difficulty": "Medium",
          "question_text": "What is the difference between `==` and the `.equals()` method when comparing objects in Java?",
          "options": [
            "A) `==` compares object content, while `.equals()` compares memory addresses.",
            "B) `==` compares memory addresses (reference equality), while `.equals()` is intended to compare object content (value equality).",
            "C) They are interchangeable and produce the same result.",
            "D) `.equals()` can only be used for String objects, while `==` can be used for any object."
          ],
          "correct_answer_index": 1,
          "explanation": "The `==` operator compares the memory locations of two objects to see if they are the exact same instance. The `.equals()` method, as defined in the `Object` class, also checks for reference equality by default. However, it is often overridden in classes (like `String`, `Integer`) to provide a 'logical' or 'value-based' equality check."
        },
        {
          "id": "d5_q014_s1",
          "domain": "JVM Architecture",
          "difficulty": "Hard",
          "question_text": "Which Garbage Collector became the default in Java 9, aiming for better pause time goals on multi-processor machines with large memory?",
          "options": [
            "A) Serial GC",
            "B) Parallel GC",
            "C) G1 (Garbage-First) GC",
            "D) ZGC"
          ],
          "correct_answer_index": 2,
          "explanation": "G1 (Garbage-First) GC was introduced to replace the Parallel GC as the default garbage collector in Java 9. It is designed for large heap sizes and aims to provide more predictable pause times by partitioning the heap into regions and collecting those with the most garbage first."
        },
        {
          "id": "d5_q015_s1",
          "domain": "Java 8 Features",
          "difficulty": "Medium",
          "question_text": "What is a key feature of the Java 8 Stream API?",
          "options": [
            "A) It is a new type of I/O stream for files.",
            "B) It provides a way to process collections of data in a functional, declarative way, supporting operations like filter, map, and reduce.",
            "C) It is a new framework for streaming video and audio.",
            "D) It replaces the Collections Framework entirely."
          ],
          "correct_answer_index": 1,
          "explanation": "The Stream API provides a sequence of elements supporting sequential and parallel aggregate operations. It allows for a functional style of programming for processing collections, which can lead to more concise and readable code compared to traditional loops. It does not store data; it pulls elements from a source through a pipeline of operations."
        },
        {
          "id": "d5_q016_s1",
          "domain": "Collections Framework",
          "difficulty": "Medium",
          "question_text": "What is the main purpose of the `hashCode()` method in Java?",
          "options": [
            "A) To generate a unique ID for every object.",
            "B) To provide a cryptographic hash of an object's state.",
            "C) To support the efficient storage and retrieval of objects in hash-based collections like `HashMap` and `HashSet`.",
            "D) To return the memory address of an object."
          ],
          "correct_answer_index": 2,
          "explanation": "The `hashCode()` method is used by hash-based collections to determine the 'bucket' where an object should be stored. The contract between `hashCode()` and `equals()` is critical: if two objects are equal according to `equals()`, they MUST have the same hash code. This allows for efficient lookups."
        },
        {
          "id": "d5_q017_s1",
          "domain": "Concurrency",
          "difficulty": "Hard",
          "question_text": "What is a `ReentrantLock` in `java.util.concurrent.locks`?",
          "options": [
            "A) A lock that can only be acquired once.",
            "B) A lock that automatically re-acquires itself after being released.",
            "C) A mutual exclusion lock that allows the same thread to acquire it multiple times without deadlocking.",
            "D) A lock that prevents re-entrant method calls."
          ],
          "correct_answer_index": 2,
          "explanation": "`ReentrantLock` implements the `Lock` interface and provides reentrant mutual exclusion. 'Reentrant' means that a thread that already holds the lock can acquire it again without blocking. It offers the same basic behavior as the `synchronized` keyword but with extended capabilities like fairness policies and interruptible lock acquisition."
        },
        {
          "id": "d5_q018_s1",
          "domain": "Exceptions",
          "difficulty": "Easy",
          "question_text": "What is the difference between a checked exception and an unchecked exception in Java?",
          "options": [
            "A) Checked exceptions occur at compile time, while unchecked exceptions occur at runtime.",
            "B) Checked exceptions must be declared in a method's `throws` clause or handled in a `try-catch` block, while unchecked exceptions do not have this requirement.",
            "C) Unchecked exceptions are subclasses of `Exception`, while checked exceptions are subclasses of `RuntimeException`.",
            "D) Checked exceptions are errors that cannot be recovered from."
          ],
          "correct_answer_index": 1,
          "explanation": "The key difference is how the compiler handles them. Checked exceptions (subclasses of `Exception` but not `RuntimeException`) are subject to the 'Catch or Specify Requirement'. Unchecked exceptions (subclasses of `RuntimeException` or `Error`) are not, as they typically represent programming errors or unrecoverable conditions."
        },
        {
          "id": "d5_q019_s1",
          "domain": "Generics",
          "difficulty": "Medium",
          "question_text": "What is Type Erasure in Java Generics?",
          "options": [
            "A) A process where generic type information is added at runtime.",
            "B) A feature that allows generic types to be erased from memory after use.",
            "C) A process where the compiler removes generic type information and replaces it with casts to ensure backward compatibility.",
            "D) An error that occurs when a generic type cannot be inferred."
          ],
          "correct_answer_index": 2,
          "explanation": "Type erasure is a mechanism in the Java compiler. It erases all generic type information at compile time, replacing type parameters with their bounds (or `Object` if unbounded) and inserting type casts where necessary. This was done to ensure that generic code could be compatible with legacy Java code written before generics were introduced."
        },
        {
          "id": "d5_q020_s1",
          "domain": "Java 8 Features",
          "difficulty": "Hard",
          "question_text": "What is the difference between an intermediate operation and a terminal operation in the Java Stream API?",
          "options": [
            "A) Intermediate operations are executed immediately, while terminal operations are lazy.",
            "B) Intermediate operations are lazy and return a new stream, while terminal operations trigger the processing and produce a result or side-effect.",
            "C) Intermediate operations can only be applied once, while terminal operations can be chained.",
            "D) Terminal operations always return a `void`."
          ],
          "correct_answer_index": 1,
          "explanation": "Stream operations are divided into two categories. Intermediate operations (like `filter()`, `map()`) are lazy; they don't execute until a terminal operation is invoked. They return a new stream, allowing operations to be chained. Terminal operations (like `forEach()`, `collect()`, `count()`) start the processing of the stream and produce a final result or side-effect."
        },
        {
          "id": "d5_q021_s1",
          "domain": "Java Language Basics",
          "difficulty": "Easy",
          "question_text": "What is the default value of a boolean primitive type in Java?",
          "options": [
            "A) true",
            "B) false",
            "C) 0",
            "D) null"
          ],
          "correct_answer_index": 1,
          "explanation": "In Java, if a boolean primitive type is declared as an instance or static variable without being initialized, it is assigned a default value of `false`. Local variables, however, must be explicitly initialized before use."
        },
        {
          "id": "d5_q022_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Medium",
          "question_text": "Can a class be both `abstract` and `final` in Java?",
          "options": [
            "A) Yes, if it has at least one abstract method.",
            "B) Yes, but it's not a common practice.",
            "C) No, because `abstract` requires a class to be subclassed, while `final` prevents it.",
            "D) Only if the class is part of the `java.lang` package."
          ],
          "correct_answer_index": 2,
          "explanation": "A class cannot be declared as both `abstract` and `final`. The purpose of an `abstract` class is to be extended by subclasses, while the `final` keyword explicitly prohibits a class from being extended. These two concepts are mutually exclusive, and the compiler will report an error."
        },
        {
          "id": "d5_q023_s1",
          "domain": "Collections Framework",
          "difficulty": "Medium",
          "question_text": "Which of these collections guarantees that the elements are processed in a First-In, First-Out (FIFO) manner?",
          "options": [
            "A) Stack",
            "B) PriorityQueue",
            "C) HashSet",
            "D) LinkedList (used as a Queue)"
          ],
          "correct_answer_index": 3,
          "explanation": "`LinkedList` implements the `Queue` interface and, when used as such (e.g., via its `add()` and `poll()` methods), provides a strict First-In, First-Out (FIFO) ordering. A `Stack` is LIFO (Last-In, First-Out), a `PriorityQueue` orders elements by priority, and a `HashSet` has no guaranteed order."
        },
        {
          "id": "d5_q024_s1",
          "domain": "Concurrency",
          "difficulty": "Hard",
          "question_text": "What is a `CountDownLatch` used for in `java.util.concurrent`?",
          "options": [
            "A) To count down from a number and then stop the application.",
            "B) A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.",
            "C) A latch that prevents more than a certain number of threads from running.",
            "D) To count how many times a lock has been acquired."
          ],
          "correct_answer_index": 1,
          "explanation": "`CountDownLatch` is a synchronizer initialized with a count. Threads can call `await()` to block until the count reaches zero. Other threads call `countDown()` to decrement the count. It's useful for making a main thread wait for the completion of several worker threads."
        },
        {
          "id": "d5_q025_s1",
          "domain": "JVM Architecture",
          "difficulty": "Medium",
          "question_text": "What is the primary role of the JIT (Just-In-Time) compiler in the JVM?",
          "options": [
            "A) To compile `.java` files into `.class` files.",
            "B) To interpret bytecode line by line.",
            "C) To improve performance by compiling frequently executed bytecode into native machine code at runtime.",
            "D) To manage the garbage collection process."
          ],
          "correct_answer_index": 2,
          "explanation": "The JIT compiler is a key component of the JVM's execution engine. It analyzes the bytecode as it runs and identifies 'hot spots' (frequently executed code). It then compiles these hot spots into optimized native machine code, which can be executed much faster than interpreted bytecode, significantly improving application performance."
        },
        {
          "id": "d5_q026_s1",
          "domain": "Java 8 Features",
          "difficulty": "Medium",
          "question_text": "Which method in the Stream API is a terminal operation that performs an action for each element of the stream?",
          "options": [
            "A) map()",
            "B) filter()",
            "C) forEach()",
            "D) peek()"
          ],
          "correct_answer_index": 2,
          "explanation": "`forEach()` is a terminal operation that consumes the stream and applies a provided `Consumer` to each element. `map()` and `filter()` are intermediate operations that return a new stream. `peek()` is also an intermediate operation used for debugging, as it performs an action on each element while still returning a new stream."
        },
        {
          "id": "d5_q027_s1",
          "domain": "Java Language Basics",
          "difficulty": "Hard",
          "question_text": "What is the difference between `String`, `StringBuilder`, and `StringBuffer`?",
          "options": [
            "A) `String` is mutable, while `StringBuilder` and `StringBuffer` are immutable.",
            "B) `String` is immutable; `StringBuffer` is mutable and thread-safe; `StringBuilder` is mutable but not thread-safe.",
            "C) `StringBuilder` is the fastest, `String` is the slowest.",
            "D) They are all mutable, but `StringBuffer` is synchronized."
          ],
          "correct_answer_index": 1,
          "explanation": "The key distinction is mutability and thread safety. `String` objects are immutable. `StringBuffer` and `StringBuilder` represent mutable sequences of characters. `StringBuffer` is thread-safe (its methods are synchronized), making it suitable for multi-threaded environments but with a performance cost. `StringBuilder` is not thread-safe but is faster, making it the preferred choice for single-threaded string manipulation."
        },
        {
          "id": "d5_q028_s1",
          "domain": "Exceptions",
          "difficulty": "Medium",
          "question_text": "What is the purpose of the `finally` block in a `try-catch-finally` statement?",
          "options": [
            "A) To execute code only if an exception is caught.",
            "B) To execute code only if no exception occurs.",
            "C) To define the final exception type to be thrown.",
            "D) To execute cleanup code regardless of whether an exception was thrown or caught."
          ],
          "correct_answer_index": 3,
          "explanation": "The `finally` block is guaranteed to be executed after the `try` block exits, whether an exception was thrown, caught, or not. Its primary purpose is for resource cleanup, such as closing files or database connections, to ensure that resources are released properly."
        },
        {
          "id": "d5_q029_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Medium",
          "question_text": "What does it mean for a class to be 'immutable'?",
          "options": [
            "A) The class cannot be extended.",
            "B) The state of an object of that class cannot be modified after it is created.",
            "C) The class can only have static methods.",
            "D) The class cannot be instantiated."
          ],
          "correct_answer_index": 1,
          "explanation": "An immutable class is one whose instances cannot have their state changed after creation. This is typically achieved by making all fields `final` and `private`, not providing any setter methods, and ensuring that any mutable object fields are defensively copied. `String` is a classic example of an immutable class in Java."
        },
        {
          "id": "d5_q030_s1",
          "domain": "Collections Framework",
          "difficulty": "Hard",
          "question_text": "What happens if you try to add a duplicate element to a `HashSet`?",
          "options": [
            "A) It throws a `DuplicateElementException`.",
            "B) The new element replaces the existing one.",
            "C) The operation is ignored, and the method returns `false`.",
            "D) The `HashSet` is converted into a `List` to allow duplicates."
          ],
          "correct_answer_index": 2,
          "explanation": "The `Set` interface, which `HashSet` implements, does not allow duplicate elements. The `add()` method of a `Set` returns a boolean value. If the element is not already present, it is added, and the method returns `true`. If the element already exists, the `add()` call does nothing and returns `false`."
        },
        {
          "id": "d5_q031_s1",
          "domain": "JVM Architecture",
          "difficulty": "Medium",
          "question_text": "A `StackOverflowError` is most likely caused by which of the following?",
          "options": [
            "A) Attempting to allocate an object that is too large for the Heap.",
            "B) An infinite loop that does not allocate memory.",
            "C) Deep or infinite recursion, causing too many method calls to be placed on the stack.",
            "D) Loading too many classes into the Method Area."
          ],
          "correct_answer_index": 2,
          "explanation": "Each thread in a Java application has its own stack, which stores frames for each method invocation. A `StackOverflowError` is thrown when a thread's stack space is exhausted. This is typically caused by very deep or infinite recursion, where method calls are nested to a point that exceeds the stack's capacity."
        },
        {
          "id": "d5_q032_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Medium",
          "question_text": "Which statement about Java constructors is true?",
          "options": [
            "A) A constructor can have a `void` return type.",
            "B) A constructor is inherited by subclasses.",
            "C) A constructor must have the same name as the class it is in.",
            "D) A class can have only one constructor."
          ],
          "correct_answer_index": 2,
          "explanation": "A constructor in Java is a special method used to initialize objects. It must have the exact same name as the class, and it does not have a return type, not even `void`. Constructors are not inherited, and a class can have multiple overloaded constructors."
        },
        {
          "id": "d5_q033_s1",
          "domain": "Java 8 Features",
          "difficulty": "Easy",
          "question_text": "Which new API was introduced in Java 8 for handling dates and times in a more robust and immutable way?",
          "options": [
            "A) java.util.Date",
            "B) java.util.Calendar",
            "C) java.time.LocalDate",
            "D) java.sql.Timestamp"
          ],
          "correct_answer_index": 2,
          "explanation": "Java 8 introduced the new Date and Time API in the `java.time` package to address the shortcomings of the old `java.util.Date` and `java.util.Calendar` classes. Classes like `LocalDate`, `LocalTime`, and `ZonedDateTime` are immutable and thread-safe, providing a much cleaner API."
        },
        {
          "id": "d5_q034_s1",
          "domain": "Collections Framework",
          "difficulty": "Medium",
          "question_text": "If you need a `List` implementation that is synchronized and thread-safe, which class would you use?",
          "options": [
            "A) ArrayList",
            "B) LinkedList",
            "C) Vector",
            "D) CopyOnWriteArrayList"
          ],
          "correct_answer_index": 2,
          "explanation": "`Vector` is a legacy class from Java 1.0 that is essentially a synchronized version of `ArrayList`. Its methods are synchronized, making it thread-safe but often with a performance penalty. `CopyOnWriteArrayList` is another thread-safe option, but `Vector` is the direct synchronized counterpart to `ArrayList`."
        },
        {
          "id": "d5_q035_s1",
          "domain": "Concurrency",
          "difficulty": "Hard",
          "question_text": "What is the purpose of the `ExecutorService` framework?",
          "options": [
            "A) To execute operating system commands.",
            "B) To manage a pool of threads for executing tasks asynchronously, decoupling task submission from execution.",
            "C) To provide a service for discovering other services on the network.",
            "D) To execute scheduled tasks only at a fixed time."
          ],
          "correct_answer_index": 1,
          "explanation": "The `ExecutorService` framework, part of `java.util.concurrent`, provides a higher-level abstraction for managing threads. It allows you to create and manage thread pools, submit tasks (`Runnable` or `Callable`) for execution, and manage the lifecycle of the service. This decouples the business logic (the task) from the thread management."
        },
        {
          "id": "d5_q036_s1",
          "domain": "Java Language Basics",
          "difficulty": "Easy",
          "question_text": "Which keyword is used to prevent a method from being overridden by subclasses?",
          "options": [
            "A) static",
            "B) private",
            "C) final",
            "D) abstract"
          ],
          "correct_answer_index": 2,
          "explanation": "The `final` keyword can be applied to methods to indicate that they cannot be overridden by any subclass. This is used when you want to enforce a specific implementation throughout an inheritance hierarchy. `private` methods are implicitly final as they are not visible to subclasses."
        },
        {
          "id": "d5_q037_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Medium",
          "question_text": "An interface in Java can contain which of the following?",
          "options": [
            "A) Only abstract methods.",
            "B) Only abstract methods and static final constants.",
            "C) Instance fields and constructors.",
            "D) Abstract methods, default methods, static methods, and static final constants."
          ],
          "correct_answer_index": 3,
          "explanation": "Since Java 8, interfaces have become more powerful. They can contain abstract methods (which are the default), `static final` constants, `default` methods (with an implementation), and `static` methods (with an implementation). They cannot contain instance fields or constructors."
        },
        {
          "id": "d5_q038_s1",
          "domain": "Generics",
          "difficulty": "Hard",
          "question_text": "What does the declaration `List<? super Number>` mean in Java Generics?",
          "options": [
            "A) A list that can hold any object that is a superclass of Number.",
            "B) A list that can hold objects of type Number or any of its superclasses (like Object).",
            "C) A list that can hold objects of any type.",
            "D) A list that can hold objects of type Number or any of its subclasses (like Integer)."
          ],
          "correct_answer_index": 1,
          "explanation": "This is a lower-bounded wildcard. `List<? super Number>` means a list of some unknown type that is a superclass of `Number`. This could be a `List<Number>` or a `List<Object>`. This type of wildcard is often used when you want to add elements of type `Number` or its subtypes to the list."
        },
        {
          "id": "d5_q039_s1",
          "domain": "Exceptions",
          "difficulty": "Medium",
          "question_text": "What is the `try-with-resources` statement, introduced in Java 7?",
          "options": [
            "A) A `try` block that attempts to allocate resources from the operating system.",
            "B) A statement that ensures any resource implementing `AutoCloseable` is automatically closed at the end of the statement.",
            "C) A `try` block that can have multiple `catch` blocks.",
            "D) A way to try acquiring a lock on a resource."
          ],
          "correct_answer_index": 1,
          "explanation": "The `try-with-resources` statement is a `try` statement that declares one or more resources. A resource is an object that must be closed after the program is finished with it. The statement ensures that each resource is closed at the end of the statement's execution, which simplifies code and avoids resource leaks."
        },
        {
          "id": "d5_q040_s1",
          "domain": "Concurrency",
          "difficulty": "Medium",
          "question_text": "What is a 'race condition' in multithreading?",
          "options": [
            "A) When two threads run a race to see which finishes first.",
            "B) A condition where the system's substantive behavior depends on the sequence or timing of uncontrollable events.",
            "C) When a thread runs faster than the main application thread.",
            "D) An error that occurs when a thread pool runs out of threads."
          ],
          "correct_answer_index": 1,
          "explanation": "A race condition is a concurrency bug that occurs when the outcome of a computation depends on the non-deterministic scheduling of two or more threads. It typically happens when multiple threads access and manipulate shared data concurrently, and the final result depends on the order in which their operations are executed."
        },
        {
          "id": "d5_q041_s1",
          "domain": "Java Language Basics",
          "difficulty": "Medium",
          "question_text": "What is the `this` keyword in Java used for?",
          "options": [
            "A) To create a new instance of the current class.",
            "B) To refer to a static member of the class.",
            "C) To refer to the current object instance from within one of its instance methods or constructors.",
            "D) To call a method in the superclass."
          ],
          "correct_answer_index": 2,
          "explanation": "The `this` keyword is a reference to the current object â€” the object whose method or constructor is being called. It can be used to disambiguate between instance variables and local variables, to call another constructor from within a constructor (constructor chaining), or to pass the current object as an argument."
        },
        {
          "id": "d5_q042_s1",
          "domain": "JVM Architecture",
          "difficulty": "Medium",
          "question_text": "What is the purpose of the `-Xmx` JVM flag?",
          "options": [
            "A) To set the initial size of the heap.",
            "B) To set the maximum size of the heap.",
            "C) To set the stack size for each thread.",
            "D) To set the size of the Metaspace."
          ],
          "correct_answer_index": 1,
          "explanation": "The `-Xmx` command-line option is used to specify the maximum heap size for the Java Virtual Machine. For example, `-Xmx512m` sets the maximum heap size to 512 megabytes. This is a critical tuning parameter for managing application memory."
        },
        {
          "id": "d5_q043_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Medium",
          "question_text": "What is method overloading?",
          "options": [
            "A) Providing two different implementations for the same method in a superclass and subclass.",
            "B) Creating a method that can handle an excessive amount of data.",
            "C) A feature that allows a class to have more than one method with the same name, as long as their parameter lists are different.",
            "D) Overriding the default behavior of a method from the `Object` class."
          ],
          "correct_answer_index": 2,
          "explanation": "Method overloading, or compile-time polymorphism, allows multiple methods in the same class to share the same name, provided they have different numbers or types of parameters. The compiler determines which version of the method to call based on the arguments provided."
        },
        {
          "id": "d5_q044_s1",
          "domain": "Java 8 Features",
          "difficulty": "Medium",
          "question_text": "Which of these is NOT a valid terminal operation in the Java Stream API?",
          "options": [
            "A) collect()",
            "B) count()",
            "C) map()",
            "D) reduce()"
          ],
          "correct_answer_index": 2,
          "explanation": "`map()` is an intermediate operation. It transforms each element of a stream and returns a new stream containing the transformed elements. `collect()`, `count()`, and `reduce()` are all terminal operations that consume the stream and produce a result."
        },
        {
          "id": "d5_q045_s1",
          "domain": "Collections Framework",
          "difficulty": "Medium",
          "question_text": "What is the primary difference between an `Iterator` and an `ListIterator`?",
          "options": [
            "A) `Iterator` can only traverse forward, while `ListIterator` can traverse both forward and backward.",
            "B) `Iterator` can modify the collection, while `ListIterator` cannot.",
            "C) `ListIterator` is faster than `Iterator`.",
            "D) `Iterator` is for `Set`, and `ListIterator` is for `List`."
          ],
          "correct_answer_index": 0,
          "explanation": "`ListIterator` is an extension of `Iterator` specifically for `List` implementations. It provides additional functionality, including bidirectional traversal (using `hasPrevious()` and `previous()`), the ability to modify the list (`add()`, `set()`), and access to the element's index."
        },
        {
          "id": "d5_q046_s1",
          "domain": "Concurrency",
          "difficulty": "Hard",
          "question_text": "What is a `Semaphore` in Java concurrency used for?",
          "options": [
            "A) To send signals between threads.",
            "B) A lock that can be acquired by multiple threads at the same time.",
            "C) To control access to a shared resource through the use of a counter or a set of permits.",
            "D) To create a semaphore-style signal light in a GUI."
          ],
          "correct_answer_index": 2,
          "explanation": "A `Semaphore` maintains a set of permits. Threads acquire a permit to access a resource and release it when they are done. If no permit is available, the thread blocks until one is released. This is a classic way to limit the number of threads that can access a resource concurrently."
        },
        {
          "id": "d5_q047_s1",
          "domain": "Java Language Basics",
          "difficulty": "Medium",
          "question_text": "What will be the output of `System.out.println('j' + 'a' + 'v' + 'a');`?",
          "options": [
            "A) java",
            "B) The code will not compile.",
            "C) 418",
            "D) j a v a"
          ],
          "correct_answer_index": 2,
          "explanation": "In Java, when the `+` operator is used with `char` primitives, it performs arithmetic addition based on their ASCII/Unicode values, not string concatenation. The ASCII values for 'j', 'a', 'v', 'a' are 106, 97, 118, 97. Their sum is 418. To get 'java', you would need to start with an empty string: `\"\" + 'j' + 'a' + 'v' + 'a'`."
        },
        {
          "id": "d5_q048_s1",
          "domain": "Exceptions",
          "difficulty": "Easy",
          "question_text": "Which class is the superclass for all errors and exceptions in the Java language?",
          "options": [
            "A) Exception",
            "B) RuntimeException",
            "C) Error",
            "D) Throwable"
          ],
          "correct_answer_index": 3,
          "explanation": "The `Throwable` class is the root of Java's exception hierarchy. Only objects that are instances of this class (or one of its subclasses) are thrown by the JVM or can be thrown by the Java `throw` statement. `Exception` and `Error` are the two main direct subclasses of `Throwable`."
        },
        {
          "id": "d5_q049_s1",
          "domain": "JVM Architecture",
          "difficulty": "Medium",
          "question_text": "In the Classloader subsystem, what is the 'delegation model'?",
          "options": [
            "A) A model where the JVM delegates task execution to the operating system.",
            "B) A model where a classloader delegates the request to load a class to its parent classloader before attempting to load it itself.",
            "C) A model where memory allocation is delegated to the garbage collector.",
            "D) A model where child classloaders can override classes loaded by parent classloaders."
          ],
          "correct_answer_index": 1,
          "explanation": "The delegation model is a core principle of Java's classloading mechanism. To load a class, a classloader first delegates the search to its parent classloader. This process continues up the hierarchy. This prevents the same class from being loaded multiple times and ensures that core Java classes are loaded by the trusted Bootstrap Classloader, which enhances security."
        },
        {
          "id": "d5_q050_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Medium",
          "question_text": "Which of these is NOT a principle of Object-Oriented Programming?",
          "options": [
            "A) Inheritance",
            "B) Encapsulation",
            "C) Polymorphism",
            "D) Normalization"
          ],
          "correct_answer_index": 3,
          "explanation": "Inheritance, Encapsulation, and Polymorphism are three of the four major principles of OOP (the fourth being Abstraction). Normalization is a concept related to database design, aimed at reducing data redundancy and improving data integrity."
        },
        {
          "id": "d5_q051_s1",
          "domain": "Java 8 Features",
          "difficulty": "Medium",
          "question_text": "How do you create a parallel stream from a collection in Java 8?",
          "options": [
            "A) By using the `new ParallelStream()` constructor.",
            "B) By calling the `.parallelStream()` method on the collection.",
            "C) By annotating the stream with `@Parallel`.",
            "D) All streams are parallel by default."
          ],
          "correct_answer_index": 1,
          "explanation": "The `Collection` interface in Java 8 was enhanced with the `parallelStream()` method, which returns a possibly parallel `Stream` with the collection as its source. This is the standard way to leverage multi-core processors for stream operations."
        },
        {
          "id": "d5_q052_s1",
          "domain": "Collections Framework",
          "difficulty": "Hard",
          "question_text": "What is the initial default capacity of an `ArrayList` if created with the no-argument constructor?",
          "options": [
            "A) 16",
            "B) 0, but the internal array is initialized to a capacity of 10 on the first element addition.",
            "C) 10",
            "D) 1"
          ],
          "correct_answer_index": 1,
          "explanation": "Since Java 7, creating an `ArrayList` with its no-arg constructor results in an empty internal array. The capacity is lazily initialized to a default of 10 only when the first element is added. This is a small optimization to save memory if the list is created but never used."
        },
        {
          "id": "d5_q053_s1",
          "domain": "Concurrency",
          "difficulty": "Hard",
          "question_text": "Which of the following is an example of a 'deadlock'?",
          "options": [
            "A) When a thread runs indefinitely without releasing resources.",
            "B) When two or more threads are blocked forever, each waiting for the other to release a resource.",
            "C) When a thread's priority is too low to get CPU time.",
            "D) When a thread tries to acquire a lock that it already holds."
          ],
          "correct_answer_index": 1,
          "explanation": "A deadlock is a classic concurrency problem where two or more threads are stuck in a state of mutual waiting. For example, Thread A holds Lock 1 and is waiting for Lock 2, while Thread B holds Lock 2 and is waiting for Lock 1. Neither can proceed, and they will be blocked indefinitely."
        },
        {
          "id": "d5_q054_s1",
          "domain": "Java Language Basics",
          "difficulty": "Medium",
          "question_text": "What is the purpose of the `static` keyword in Java?",
          "options": [
            "A) To make a variable or method belong to an instance of a class, rather than the class itself.",
            "B) To make a variable constant and unchangeable.",
            "C) To make a variable or method belong to the class, rather than to any specific instance of the class.",
            "D) To indicate that a method cannot be inherited."
          ],
          "correct_answer_index": 2,
          "explanation": "The `static` keyword indicates that the particular member belongs to the type itself, rather than to an instance of that type. This means you can access static members without creating an object of the class. There is only one copy of a static member, shared among all instances of the class."
        },
        {
          "id": "d5_q055_s1",
          "domain": "Generics",
          "difficulty": "Medium",
          "question_text": "Why were Generics introduced in Java 5?",
          "options": [
            "A) To improve the performance of collections.",
            "B) To allow collections to store primitive types directly.",
            "C) To provide compile-time type safety for collections and eliminate the need for casting.",
            "D) To add new types of collections to the framework."
          ],
          "correct_answer_index": 2,
          "explanation": "The primary motivation for adding generics to Java was to provide stronger type checks at compile time. Before generics, collections stored objects of type `Object`, requiring developers to manually cast them back to their original type, which was error-prone. Generics allow you to specify the type of objects a collection can hold, and the compiler enforces this, catching errors early."
        },
        {
          "id": "d5_q056_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Hard",
          "question_text": "What is the difference between composition and inheritance?",
          "options": [
            "A) Composition is a 'has-a' relationship, while inheritance is an 'is-a' relationship.",
            "B) Inheritance is a 'has-a' relationship, while composition is an 'is-a' relationship.",
            "C) Composition is used for code reuse, while inheritance is not.",
            "D) They are different terms for the same concept."
          ],
          "correct_answer_index": 0,
          "explanation": "This is a fundamental design principle. Inheritance represents an 'is-a' relationship (e.g., a `Dog` is an `Animal`). Composition represents a 'has-a' relationship (e.g., a `Car` has an `Engine`). The common design advice 'favor composition over inheritance' suggests that it is often more flexible to build classes by composing them from other classes rather than inheriting from them."
        },
        {
          "id": "d5_q057_s1",
          "domain": "JVM Architecture",
          "difficulty": "Medium",
          "question_text": "What is stored in a thread's Program Counter (PC) Register?",
          "options": [
            "A) The total number of instructions executed by the thread.",
            "B) The memory address of the next bytecode instruction to be executed.",
            "C) A pointer to the thread's current stack frame.",
            "D) The priority level of the thread."
          ],
          "correct_answer_index": 1,
          "explanation": "The PC Register is a small, per-thread memory area that contains the address of the Java Virtual Machine instruction currently being executed. If the method is native, the value of the PC register is undefined."
        },
        {
          "id": "d5_q058_s1",
          "domain": "Java 8 Features",
          "difficulty": "Medium",
          "question_text": "A lambda expression in Java can be used to provide an implementation for which type of interface?",
          "options": [
            "A) Any interface.",
            "B) A marker interface (an interface with no methods).",
            "C) A functional interface (an interface with a single abstract method).",
            "D) Only interfaces from the `java.util.function` package."
          ],
          "correct_answer_index": 2,
          "explanation": "Lambda expressions provide a concise way to implement the single abstract method of a functional interface. The compiler can infer the method signature from the context in which the lambda is used, making the code much more compact."
        },
        {
          "id": "d5_q059_s1",
          "domain": "Collections Framework",
          "difficulty": "Hard",
          "question_text": "What is a `ConcurrentModificationException`?",
          "options": [
            "A) An exception thrown when two threads modify a file at the same time.",
            "B) An exception thrown when a collection is modified while it is being iterated over in a way that is not permitted by the iterator.",
            "C) A checked exception that must be handled when using concurrent collections.",
            "D) An exception thrown when modifying a `final` collection."
          ],
          "correct_answer_index": 1,
          "explanation": "This exception is thrown by 'fail-fast' iterators (like those for `ArrayList` and `HashMap`) if they detect that the underlying collection has been structurally modified (e.g., an element was added or removed) by a means other than the iterator's own `remove()` method during iteration."
        },
        {
          "id": "d5_q060_s1",
          "domain": "Concurrency",
          "difficulty": "Hard",
          "question_text": "How can you create a daemon thread in Java?",
          "options": [
            "A) By extending the `DaemonThread` class.",
            "B) By passing `true` to the `setDaemon()` method of a `Thread` object before it is started.",
            "C) By annotating the thread's `run()` method with `@Daemon`.",
            "D) All threads are daemon threads by default."
          ],
          "correct_answer_index": 1,
          "explanation": "A daemon thread is a low-priority thread that runs in the background. The JVM does not wait for daemon threads to finish before exiting. You can mark a thread as a daemon by calling its `setDaemon(true)` method. This must be done before the thread is started, or an `IllegalThreadStateException` will be thrown."
        },
        {
          "id": "d5_q061_s1",
          "domain": "Java Language Basics",
          "difficulty": "Easy",
          "question_text": "What is the entry point for any standalone Java application?",
          "options": [
            "A) The `start()` method.",
            "B) The main constructor of the primary class.",
            "C) The `public static void main(String[] args)` method.",
            "D) The `init()` method."
          ],
          "correct_answer_index": 2,
          "explanation": "The Java Virtual Machine starts execution by looking for a method with the exact signature `public static void main(String[] args)`. This method serves as the starting point for the program's execution."
        },
        {
          "id": "d5_q062_s1",
          "domain": "Object-Oriented Programming",
          "difficulty": "Medium",
          "question_text": "Can an abstract class have a constructor in Java?",
          "options": [
            "A) No, because abstract classes cannot be instantiated.",
            "B) Yes, and it can be called directly to create an instance.",
            "C) Yes, it is called implicitly when a concrete subclass is instantiated to initialize the superclass part of the object.",
            "D) Only if the abstract class has no abstract methods."
          ],
          "correct_answer_index": 2,
          "explanation": "Yes, an abstract class can have a constructor. While you cannot directly instantiate an abstract class, its constructor is invoked (via `super()`) from the constructor of its concrete subclasses. It is used to initialize the state defined in the abstract class."
        },
        {
          "id": "d5_q063_s1",
          "domain": "Exceptions",
          "difficulty": "Medium",
          "question_text": "What happens if an exception is thrown in a `try` block and there is no matching `catch` block?",
          "options": [
            "A) The program continues execution from the `finally` block and then terminates.",
            "B) The `finally` block (if present) is executed, and then the exception propagates up the call stack.",
            "C) The program terminates immediately without executing the `finally` block.",
            "D) The compiler reports an error."
          ],
          "correct_answer_index": 1,
          "explanation": "If an exception is not caught by any `catch` block within a method, the `finally` block is still executed. After the `finally` block completes, the exception is propagated up to the calling method, where the process repeats. If it reaches the top of the call stack (the `main` method) without being caught, the program terminates."
        },
        {
          "id": "d5_q064_s1",
          "domain": "Collections Framework",
          "difficulty": "Medium",
          "question_text": "Which `Map` implementation maintains the insertion order of its entries?",
          "options": [
            "A) HashMap",
            "B) TreeMap",
            "C) Hashtable",
            "D) LinkedHashMap"
          ],
          "correct_answer_index": 3,
          "explanation": "`LinkedHashMap` is a subclass of `HashMap` that maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order)."
        },
        {
          "id": "d5_q065_s1",
          "domain": "Concurrency",
          "difficulty": "Hard",
          "question_text": "What is a `Future` object in Java concurrency?",
          "options": [
            "A) An object that predicts the future state of the application.",
            "B) A placeholder for a result that is not yet available from an asynchronous computation.",
            "C) A configuration object for future scheduled tasks.",
            "D) A new type of thread that runs in the future."
          ],
          "correct_answer_index": 1,
          "explanation": "A `Future` represents the result of an asynchronous computation. When you submit a `Callable` to an `ExecutorService`, it returns a `Future`. You can use this `Future` to check if the computation is complete, to wait for its completion, and to retrieve the final result once it's available, using the `get()` method."
        }
      ]
    }
  ]
}
